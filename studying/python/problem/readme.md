# 202007

## 20200702

1. [encode] utf-8 是 可变长的 unicode 编码，python 3 的字符串是以 unicode 编码，在计算机内存中，统一使用 unicode 编码，当需要保存到磁盘或需要传输时，就转换为 utf-8 编码，用记事本编辑时，从文件读取 utf-8 字符，并转换为 unicode 字符到内存里

2. [str] 字符转整数编码使用 ord()，编码转字符使用 chr()，解码忽略错误字节使用 b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')

3. [#] #!/usr/bin/env python3 告诉 Linux/OS X 系统这是一个 Python 可执行程序，Windows 忽略这行注释，# -_- coding: utf-8 -_- 告诉 python 解释器，要按照 utf-8 编码读取源代码

4. [format]

| 占位符 | 替换内容     |
| ------ | ------------ |
| %d     | 整数         |
| %f     | 浮点数       |
| %s     | 字符串       |
| %x     | 十六进制整数 |
| %%     | 转义%        |

```python
>>> print('Hello, %s: %2d-%02d, %.2f, %x' % ('world', 3, 1, 3.1415926, 10))
Hello, world:  3-01, 3.14, a
>>> print('%%Hello, %s: %2d-%02d, %.2f, %x' % ('world', 3, 1, 3.1415926, 10))
Hello, world:  3-01, 3.14, a
```

## 20200705

1. [GIL] Global Interpreter Lock，任何 Python 线程执行前，必须先获得 GIL 锁，然后，每执行 100 条字节码，解释器就自动释放 GIL 锁，让别的线程有机会执行。这个 GIL 全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核 CPU 上，也只能用到 1 个核。

## 20200709

1. [不可变对象] 不可变对象：str，tuple 可变对象：list

2. [函数的参数] 以下 5 种参数都可以组合使用，但定义顺序必须是：位置参数，默认参数，可变参数，命名关键字参数，关键字参数

| 参数类型       | 说明                                                                                                                             |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| 位置参数       | 参数有固定位置                                                                                                                   |
| 默认参数       | 位置参数的基础上给定默认值，默认值必须指向不可变对象                                                                             |
| 可变参数       | 参数个数是可变的，这些参数在函数内部自动组装成一个 tuple， \*把 list 的所有元素作为可变参数传入函数                              |
| 关键字参数     | 任意个含参数名的参数，这些参数在函数内部自动组装成一个 dict， \*\*把 dict 的所有元素作为关键字参数传入函数                       |
| 命名关键字参数 | 以一个 \* 分隔，\* 后面的参数被视为命名关键字参数，如果函数定义中已经有一个可变参数，后面跟着的命名关键字参数就不再需要分隔符 \* |

3. [生成器] 使用 next() 最终会得到一个 StopIteration 错误和 return 语句的返回值，for 迭代不会返回错误和返回值

4. [高阶函数] 变量可以指向函数，函数的参数可以接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数；函数式编程就是指这种高度抽象的编程范式

5. [map,reduce] map 将传入的函数依次作用在序列的每个元素，并把结果作为新的 iterator 返回；reduce 把一个函数作用在一个序列上，这个函数接收两个参数，reduce 把结果继续和序列的下一个元素做累计计算

## 20200711

1. [Closure] 在函数中又定义了函数，且外部函数 return 内部函数，这种程序结构被称为“闭包”，闭包每次调用都会返回一个新的函数

2. [global, nonlocal] global 用于定义全局变量或声明在其他局部作用域中使用全局变量（如果不修改变量值可以不声明），nonlocal 用来声明在其他作用域使用外层非全局变量；使用外层变量时，若修改外层变量的值而不实用 global 或 nonlocal 声明，解释器会报错

3. [decorator] 在代码运行期间动态增加功能的方式，称为装饰器；装饰器的本质是一个返回函数的高阶函数；使用装饰器时，需要接收一个函数，并返回一个包装函数 wrapper，在包装函数内部执行接收的函数，可以借助 python 的 @语法；如果装饰器本身需要传入参数，则需要定义一个返回 decorator 的 decorator，通过给外层 decorator 传参返回一个包含该参数的内层 decorator，内层返回的 wrapper 与无参 decorator 定义相同，只是 wrapper 内部可以使用外层 decorator 传入的参数了；使用 @functools.wraps 装饰 wrapper 可以复原装饰对象函数的函数名，相当于在装饰器内部调用 wrapper.\_\_name** = func.\_\_name**

4. [装饰模式] 在 OOP 的设计模式中，decorator 被称为装饰模式；OOP 的装饰模式需要通过继承和组合来实现，而 python 除了支持 OOP 的 decorator，从语法层面也支持 decorator，python 的 decorator 可以用函数实现，也可以用类实现

5. [functools.partial] 偏函数定住前面定参数后，要给后面定参数赋值，可以使用关键字参数赋值定方式；更好定方式是将变化大的参数放在参数列表的后面，使用偏函数时只用定住后面的参数

6. [modules] 导入 modules 后，就有了变量 module name 指向这个 module，利用这个 module name 可以访问 module 的所有功能；默认情况下，解释器会搜索依次当前目录、所有已安装内置模块、第三方模块，搜索路径存放在 sys 模块的 path 变量中

7. [sys] sys.argv 至少有一个变量，就是被运行 .py 文件的名称；解释器将被运行 .py 模块的特殊变量 \_\_name** 置为 '\_\_main**' ,而被导入并间接使用的模块不会设置 \_\_name** = '\_\_main**'

8. [OOP] Object Oriented Programing，把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数；面向对象程序设计把计算机程序视为一组对象的集合，每个对象都可以接收其他对象发过来的信息并处理这些信息，计算机程序的执行就是一系列消息在各个对象之间传递；python 所有类型都可以视为对象

9. [class] 和静态语言不同，python 允许对实例变量绑定任何数据，也就是说对于两个实例变量，即使他们是同一个类的不同实例，拥有的变量名称可能是不同的

10. [private] \__property\_\_ 是特殊变量，不是 private 变量，可以被直接访问，_ 是约定外部不要随意访问的变量，也可以访问，** 是 private 变量，解释器会把 \_\_property 变量改成 \_Class**property，\_\_property 不能直接访问

11. [多态] 定义时使用父类，调用时实际执行传入的子类实现

12. [开闭原则] 对扩展开发，对修改封闭

13. [\__slots\__] 可以限制实例动态添加属性，只有 \_\_slots** 元组中标记的属性可以被动态添加到实例；如果子类没有标记 \_\_slots**，则父类的 \_\_slots** 只在父类中有效，如果子类有标记 \_\_slots**，则子类的限制范围是父类的 \_\_slots** 加子类自己的\_\_slots**

14. [MixIn] python 允许一个子类继承自多个父类；在设计类时，优先考虑通过多重继承来组合多个 MixIn 的功能，而不是设计多层复杂的继承关系；

15. [\__getattr\__] 只有在没有找到属性的情况下才会调用 \_\_getattr**，已有的属性，不会在 \_\_getattr** 中查找

16. [\__call\__] 在类中定义 \_\_call\_\_ 可以直接对类的实例调用；这样对象就可以看成一个函数；使用 callable(obj) 判断 obj 是否是可被调用的

17. [!] 动态语言与静态语言相较，最大的不同是，函数和类的定义不是编译时定义的，而是运行时动态创建的；要使用静态语言在运行期创建类，需要先构造源代码字符串，再调用编译器生成字节码，本质上是动态编译

## 20200712

1. [process] 父进程所有的 python 对象都必须通过 pickle 序列化再传到子进程去，所以，如果 multiprocessing 调用失败，要先考虑是否 pickle 失败了

2. [ThreadLocal] ThreadLocal 可以创建全局 threadlocal 对象，每个 Thread 都可以对它读写自己的变量，但互不影响，且内部自动处理锁问题；可以理解为一个线程安全但 dict 对象

3. [计算密集 vs, IO 密集] 计算密集型任务主要消耗 CPU 资源，代码运行效率是关键，最好使用 C 语言；IO 密集型 99%时间花费在 IO 上，花在 CPU 上的时间很少，选用开发效率最好的语言为好；异步 IO 基于事件驱动完成单进程单线程执行多任务

4. [分布式] master 与 worker 间信息传递应只是传递任务和接收结果（比如使用 Queue 通信），每个任务的描述数量要尽量小，而不要发送任务中处理的数据本身，这些要处理的数据由 worker 进程自行去共享磁盘读取

5. [re] re 的 pattern 特殊字符以\ 转义，python 特殊字符也以 \ 转义，如果 pattern 字符串没有以 r 前缀标注，则在需要转义的字符前需要两个 \ 表示特殊字符

6. [ChainMap] 可以把一组 dict 串联并组成一个逻辑上的 dict，在查找时，会按照给定顺序在内部的 dict 依次查找

7. [x] 0x 表示十六进制的 int 型变量，\x 表示十六进制的字符型变量，0x61 表示 int 型十进制 97，‘x61’表示字符型 ascii 码十进制 97 号字符'a'，b'\x61'表示 byte 型 ascii 码十进制 97 号字符，即 b'a'

8. [contextlib] 实现上下文管理的三种方式：通过实现 \_\_enter** 和 \_\_exit**；通过 @contextmanager 实现一个 generator；通过 closing 转换

## 20200713

1. [email] 发件人 -> MUA [Mail User Agent] -> MTA [Mail Transfer Agent] -> MTA -> 若干个 MTA -> MDA [Mail Delivery Agent] <- MUA <- 收件人

2. [web] web 开发的四个阶段

| 阶段          | 说明                                                                                                     |
| ------------- | -------------------------------------------------------------------------------------------------------- |
| 静态 Web 页面 | 由文本编辑器直接编辑成静态 HTML 源代码用在 Web 页面上展示，早期互联网 Web 页面就是静态的，无法与用户交互 |
| CGI           | Common Gateway Interface，C/C++ 编写的用于处理用户发送的动态数据的接口                                   |
| ASP/JSP/PHP   | 脚本语言，用与 HTML 结合紧密的 VBScript, Java, PHP 编写脚本生成 Web 页面                                 |
| MVC           | 解决脚本语言签入 HTML 维护性差的问题，引入 Model-View-Controller 模式                                    |
| MVVM          | ...                                                                                                      |

3. [IO] 在一个线程中，CPU 执行代码的速度极快，然而一旦遇到 IO 操作就需要等待 IO 操作完成才能继续下一步操作，这种情况称为同步 IO；当代码需要执行一个耗时的 IO 操作时，CPU 只发出 IO 指令，并不等待 IO 结果，然后就去执行其他代码了，一段时间后，当 IO 返回结果时，在通知 CPU 进行处理，这种 IO 方式叫做异步 IO；异步 IO 可以大大提升 IO 密集型应用程序的多任务处理能力

4. [协程] Python 对协程的支持是通过 generator 实现的；子程序就是协程的一种特例

5. [generator] send：向生成器发送一个值，随后恢复执行；throw：在生成器暂停的地方抛出类型为 type 的异常，并返回下一个 yield 的返回值；close：在生成器函数暂停的地方抛出一个 GeneratorExit 异常
