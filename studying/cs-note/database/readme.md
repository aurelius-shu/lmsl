# 数据库系统原理

## 事务

**ACID**

### Atomicity

原子性，事务不可拆分，最小单元，全部提交成功，或全部失败回滚（undo log 反向执行）

### Consistency

一致性，事务执行前后保持一致性状态，所有事务对同一数据的读取结果相同

### Isolation

隔离性，一个事务的修改在最终提交以前对其他事务不可见

### Durability

持久性，事务一旦提交，所做修改将永久保存，即使几桶故障奔溃（redo log 重做）

## 并发一致性问题

`原因` 破坏了事务的隔离性
`解决方法` 通过并发控制（锁 -> 事务的隔离级别）保证隔离性

### 丢失修改

一个事务`未提交`的更新操作被另一个事务的更新操作覆盖

### 胀读

一个事务读取到另一个事务未提交的修改

### 不可重复度

一个事务重复读取到另一个事务修改提交前后的数据

### 幻影读

一个事务重复读取到另一个事务增删提交前后的数据

## 封锁

### 粒度

锁定数据量越少，锁争用可能越小，系统并发度越高，但锁开销(获取锁、释放锁、检测锁状态)也越高

1. 行锁
2. 表锁
3. 间隙锁

### 类型

#### 读写锁

1. 互斥锁（Exclusive），X 锁，写锁；获得 X 锁的事务可以进行读取和更新，其他事务不能附加任何锁
2. 共享锁（Shared），S 锁，读锁；获得 S 锁的事务可以进行读取，其他事务不能附加 X 锁，可以附加 S 锁

#### 意象锁

**IX/IS 都是表锁**

1. 一个事务想要获得某数据的 X 锁，必须先获得表的 IX 锁
2. 一个事务想要获得某数据的 S 锁，必须先获得表的 IS 锁或跟强锁

### 锁协议

#### 三级封锁协议

`一级封锁协议` 事务 T 要修改数据 A 时必须对 A 加 X 锁，直到 T 结束才能释放 -> 解决`修改丢失`
`二级封锁协议` 在一级封锁协议基础上，事务 T 在读取数据 A 时必须对 A 加 S 锁，读完马上释放 S 锁 -> 解决胀读
`三级封锁协议` 在二级封锁协议基础上，事务 T 在读取数据 A 是必须对 A 加 S 锁，直到 T 结束才能释放 -> 解决不可重复度

#### 两段锁协议

加锁和解锁分为两个阶段进行

## 隔离级别

### READ UNCOMMITTED

未提交读，事务没有提交的修改其他事务也可见

### READ COMMITTED

提交读，事务只能读取已提交事务的修改

### REPEATABLE READ

可重复读，同一个事务中多次读取同一数据的结果是一样的

### SERIALIZABLE

可串行化，（加锁）强制事务串行化，多事务互不干扰，无并发一致性问题

## MVCC

多版本并发控制，InnoDB 存储引擎实现`提交读`和`可重复读`隔离级别的一种具体方式，避免了 SELECT 的加锁
未提交读要求低，无需 MVCC，串行化要求对所有读取的行都加锁，单纯 MVCC 无法实现

MVCC 利用多版本，类似 CopyOnWrite，写操作更新最新的版本快照，而读操作去读旧版本快照，解除读锁与写锁的`互斥`关系
MVCC 的事务中修改操作（DELETE, INSERT, UPDATE）会为数据行新增一个版本快照
MVCC 规定只能读取已提交的快照（解决胀读），且一个事务读取固定版本快照（解决不可重复读）

### Version

SYS_ID: 系统版本号，递增数字，没开始一个新的事务，系统版本号自增 1
TRX_ID: 事务版本号，事务开始时的系统版本号

### Undo Log

MVCC 多版本指多个版本的快照，快照存储在 Undo Log 中，通过回滚指针 ROLL_PTR 连接一个数据行的所有快照

### ReadView

MVCC 维护一个 ReadView 结构，包含当前系统未提交的事务列表 TRX_IDs，列表最小值 TRX_ID_MIN，最大值 TRX_ID_MAX

**SELECT 操作可读取的快照版本**

`TRX_ID < TRX_ID_MIN` 可读
`TRX_ID > TRX_ID_MAX` 不可读
`TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX` 需要根据隔离级别再进行判断

- 提交读：不可读
- 可重复读：不可读

快照版本不可读时，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照版本，重复判断

### 快照读与当前读

1. 快照读，MVCC 中的 SELECT 即快照读，无需加锁
2. 当前读，MVCC 中的修改操作需要读取最新数据，需要加锁

## Next-Key Locks

InnoDB 一种锁实现，解决幻读问题（在可重复读隔离级别下，MVCC + Next-Key Locks）

### Record Locks

锁定一个记录上的索引，而不是记录本身（无索引时自动在主键创建聚簇索引）

### Gap Locks

锁定索引之间的间隙（不包含索引本身）

### Next-Key Locks

Record Locks 与 Gap Locks 的结合，锁定索引本身及索引之间的间隙（前开后闭区间）

## 关系数据库设计理论

### 函数依赖

键码：关系中决定其他所有属性的最小集合

### 范式

1. 1NF 原子性，属性不可分
2. 2NF 唯一性，非主属性完全依赖于主键，消除部分依赖
3. 3NF 冗余性，非主属性不依赖于其他非主属性，消除传递依赖

## ER 图

### 实体的三种关系

一对一： 两个不带箭头的线段
一对多： 带箭头的线段指向多
多对多： 带双向箭头的线段
